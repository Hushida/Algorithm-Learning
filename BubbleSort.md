# 冒泡排序算法
===
冒泡排序的思想比较简单。假设需要把数组的书按照从小到大的顺序排列，
结果为第一个最小，最后一个最大。

首先把第一个和第二个元素比较，如果第一个比第二个还大，就把他们两个
交换位置，然后比较第二个和第三个元素，以此类推，直到比较到最后一个
元素为止。这才完成第一趟排序，第一趟排序的结果是把最大的元素放到数
组的最后一个位置。第二趟排序会把大小排名第二的元素放到倒数第二个位
置上去。n个元素的数组，一共需要进行n-1趟排序，最后使整个数组是从小
到大按顺序排列。算法的实现如下所示（java）

*输入：一个数组array，排序范围array[low...high]*
*输出有序的数组array[low...high]*

```
public void BubbleSort(int[] array, int low, int high) {
    int sortLength = (high - low);
    for(int i = 0; i < sortLength; i++) {
        for(int j = i; j < sortLength; j++) {
            if(array[j] > array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}//end of BubbleSort
```
**时间复杂度**  
最好的情况：如果数组已经有序，而且是从小到大排列，那么n个元素的
数组只需要比较n-1次比较，不需要交换顺序，时间复杂度是O(n)。    
最坏的情况：如果数组已经有序，但是和我们需要的顺序相反，那么一
共需要n-1趟排序，第一趟都需要交换n-1次，第二趟需要交换n-2次，加
起来是个等差数列求和，n(n -1 )/2, 时间复杂度是O(n*n)。

**空间复杂度**   
只使用了一个辅助空间，所以时间复杂度是O(1)。
